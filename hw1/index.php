<?php
/**
 * Created by PhpStorm.
 * User: MaDMaxX
 * Date: 16.08.17
 * Time: 19:07
 */
/*
1. Придумать класс, который описывает любую сущность из предметной области
интернет-магазинов: продукт, ценник, посылка и т.п.
2. Описать свойства класса из п.1 (состояние).
3. Описать поведение класса из п.1 (методы).
4. Придумать наследников класса из п.1. Чем они будут отличаться?
 */

class Product {

	protected $name;
	protected $cost;
	protected $producer;

	function __construct($name, $cost, $producer = '') {
		$this->name = $name;
		$this->cost = $cost;
		$this->producer = $producer;
	}

	function getProduct() {
		return "$this->name $this->producer $this->cost";
	}


}

class ProductExtended extends Product {

	protected $attributes = array();

	function __construct($name, $cost, $producer) {
		parent::__construct($name, $cost, $producer);
	}

	function setAttributes ($attributes) {
		$this->attributes = $attributes;
	}

	function getProduct() {
		return parent::getProduct() . ' ' . $this->getAttributes(); // TODO: Change the autogenerated stub
	}

	function getAttributes() {

		if (!$this->attributes) return;

		$str = '(';
		foreach ($this->attributes as $key=>$attr) {
			$str .= "$key: $attr, ";
		}
		$str = substr($str, 0, strripos($str, ', '));
		$str .= ')';

		return $str;

	}
}

$prod = new Product('Майка' , 220, 'Адидас');
echo $prod->getProduct() . '<br/>';

$prod2 = new ProductExtended('Футболка', 330, 'Нике');
$attr = array('Рамер' => 32, 'Цвет' => 'Красный');
$prod2->setAttributes($attr);
echo $prod2->getProduct();

//Дан код:
//Что он выведет на каждом шаге? Почему?

class A {
	public function foo() {
		static $x = 0;
		echo ++$x;
	}
}
$a1 = new A();
$a2 = new A();
$a1->foo(); // 1
$a2->foo(); // 2
$a1->foo(); // 3
$a2->foo(); // 4

// переменная $x является статична и она пренадлежит классу а не экземпляру, так что при каждом вызове
// метода foo будет значение увеличивается на единицу

class A1 {
	public function foo() {
		static $x = 0;
		echo ++$x;
	}
}
class B1 extends A1 {
}
$a1 = new A1();
$b1 = new B1();
$a1->foo(); // 1
$b1->foo(); // 1
$a1->foo(); // 2
$b1->foo(); // 2

// так как у нас два класса и у каждого из них статическая переменная $x своя
